# Machine Learing and Data Science
1) **Naive Bayes classifier** for categorical data from scratch in Python 
2) **Naive Bayes classifier** for continuous data from scratch in Python 
3) **Data Visualization:** Showing Iris dataset with Blender API
4) **Norms in vector space:** A review of norms, and reminding p-norms are included. Finally, we compare some special p-norms.
5) **Inner products in vector space:** Reminding dot product and Frobenius inner product, and then canonical norms based on them. There are examples with module *numpy*.
6) **Gram-Schmidt** process: An algorithm to convert a linearly independent set of vectors into an orthogonal set of vectors.
7) **Boxplot:** The elements of a **boxplot** are reviewed here, including: medians, quartiles, fences, and outliers.
8) **Probability, standard terms:** such as sample space, trial, outcome, and event.
9) **Logisitic function:** It is an S-shaped curve, which is widely used in machine learning and neural networks.
10) **Sigmoid functions (curves):** Some examples are included. They are widely used in neural networks and deep learning.
11) **Conditional probability:** We review the conditional probability and based on it, we get the multiplication rule. 
12) **Inclusion-exclusion principle:** We review this principle both in set theory and in probability. Python code is also provided. 
13) **Probability, independent events:** The property of independent events are mentioned here. Also, multiplication rule is included with some examples.
14) **Probability, Bayes' rule:** The Bayes' rule is expressed here along the total probability theorem. Bayes' rule is defined by conditional probabilities. Some Python code are included too.
15) **Linear Regression with Least Squares**:  When we assume the data points are related through a linear function, we can predict the dependent variable from independent variabe(s). This is a lienar regression. One way to find the parameters of a linear regression is to use a Least Squares estimator. The related Python code clarifies this topic.
16) **Ridge Regression with Least Squares**: Ridge regression is an extension of linear regression in which a penalty term is included in the loss function. This penalty term is called regularization term. Ridge regression is especially useful when data points are noisy and/or having outliers. It also shows robustness against overfitting.
17) **Gradient Descent for Linear and Ridge Regression:** This time we are going to use the *Gradient Descent method* for finding the minimum of loss function of *ridge regression* and *linear regression*. For a deeper look at the Gradient Descent (GD), see our repository for *Optimization*.
18) **Gradient and tangent  planes:** For a surface in the form of f(x,y,z)=constant, its gradient vector is orthogonal to the surface at that point. With this property, we can get the equation for tangent planes to a surface or a level curve. It is reminded that a tangent plane is a *linear approximation* to the given function.
19) **Lasso regression and Elastic Net**: After becoming familar with *Ridge regression*, we should become acquainted with *Lasso* and *Elastic Net*. In Lasso, we use the *L1* norm for the regularization term. However, in Elastic Net, we employ both *L1* and *L2* norms for regularization. This post mentions Lasso and Elastic Net with an example on a real dataset for *classification* using *subgradient method*.
20) **Coordinate Descent for Lasso:** In the previous post, we talked about *Lasso regression*, which was done by *subgradient method*. In this post, however, we use the *coordinate descent* for Lasso regression. For a deeper discussion on *Coordinate Descent*, see our post in the repository of **Optimization**.
21) **Probability, Discrete Random Variables:** Discrete random variables take values from a *countable* set. When we have discrete random variables, their distribution is defined by a step function. Here, we use *Bernoulli distribution* as an example of those representing discrete random variables. Also, we compute the *entropy* of a Bernoulli distribution for different values of its parameter. 
22) **Probability, Continuous Random Variables:** Continuous random variables often take values from an interval of real numbers. In fact, when we measure things such as speed, voltage, profit, and etc; we are dealing with continuous random variables. As an example, we review the *continuous uniform distribution function* and its *probability (density) function*.  
23) **Maximum Likelihood Estimation:** When we have a number of samples taken from a probability function, which we do not know its parameters, one way to estimate the parameters is to use the *maximum likelihood estimation* (MLE). Here, we review the MLE and apply it to two examples.
24) **MLE (maximum likelihood estimation) for a multivariate normal distribution:** We have *n* data points of the same multivariate normal distribution, which are independent. The parameters of the normal distribution, *mean vector* and *covariance matrix*, are unknown. By the MLE, we develop formulae to estimate those parameters. The Python code provides an example and shows the *ellipse* of the estimated covariance matrix.
25) **Mixture distributions:** In a mixture distribution, we have a collection of individual distributions from which samples are taken based on a probability *weights*. Here, this kind of disribution is reviewed along an example with *normal* (Gaussian) distributions in Python code. 
26) **Voronoi diagram:** Voronoi diagram or **tessellation** is a *partition* of points in a *metric space* based on their closeness to some given points named **seeds**. For a seed, the region of the space for which the points are closest to the seed is called the **Voronoi cell** of the seed. In this Notebook, we express the Python codes to partition the 2D Euclidean space into Voronoi cells. Two famous *distance functions*, **Euclidean** and **Manhattan**, are mentioned with examples.
27) **The k-means clustering:** The k-means algorithm is used for *clustering* when the number of clusters is given in advance. It is a widely-used clustering algorithm. Several versions of the k-means have also been proposed. Each cluster is represented by the mean of its data points. That is why it is called the k-means. In this notebook, we implement the standard k-means algorithm from scratch in Python. And the *iris* dataset is employed for the clustering. It should be reminded that the k-means is related to *Voronoi diagram* expressed in the previous post.
28) **Gaussian Mixture Models with the EM algorithm**: A Gaussian mixture model (GMM) is a probabilistic model in which we assume the data points come from a mixture of several **Gaussian** (normal) distributions with unknown parameters. The **Expectation-Maximiation** (EM) algorithm has been used for estimating the unknown parameters of a GMM given some data points. Here, we provide the EM algorithm for the GMMs from scratch in Python with an example using the iris dataset.  
29) **Expected value:** The expected value or **expectation** is a weighted average of all possible outcomes, where the weights are the probabilities of each outcome. And it is a measure of the central tendency of a random variable. Here, we express the expected value for both *discrete* and *continuous* randam variables with examples in Python.
30) **Law of total expectation:** The law of total expectation allows us to compute the overall expectation E[X] by breaking it into smaller, conditional expectations E[X|Y=y]. This approach is particularly useful when X depends on another random variable Y, and it is easier to compute E[X|Y=y] first. Here, we use the law of total expectation when Y is a discrete random variable, and also when Y is a continuous random variable. The examples are in Python.
31) **Radial basis functions, definiton:** A radial basis function (RBF) is a radial function which positive definite (PD). This positive definitness is defined based on the **interpolation** matrix that is formed by distint points as inputs to the radial function. For cetain radial functions, the interpolation matrix is nonsingular, which we call them to be the stricly radial basis functions. Here, three radial basis functions (RBFs) are reviewed with *Python* code. Later, we will use RBFs for interpolation and **approximation**. 
32) **Radial basis functions for interpolation:** In the previous post, we reviewed RBFs (radial basis functions). In this post, we use RBFs for interpolation. When we use an RBF, which is strictly positive definite, then the iterpolation matrix is nonsingular; and thus the parameters of the interpolation function is computed in an straightforward manner. We express the formulae and the Python code of RBF for interpolation.
33) **RBF (radial basis function) networks:** This time we use RBFs for function approximation in a three-layer structure. The RBFs are placed in the hidden layer of an RBF network. Each RBF has a center point and a width. The center points are usually obtained as the cluster centers of the input data points. The widths of the RBFs are usually selected by a heuristic. The weights of the output layer are estimated by a gradient descent method or pseudo-inverse. The complete Python code of an RBF network with the bias term and regularization, which uses stochastic gradient descent (SGD), is provided here.
34) **An artificial neuron:** Any complex artificial neuroal network is mostly composed of several artificial neurons. Here, we review a model of an artificial neuron. The Python code is also provided.
35) **Multilayer perceptron for regression:** Multilayer perceptron is a *feedforward neural network* in which we often use the **backpropagation** algorithm to adjust its weights ans biases by the given sample data. 
Here, we define and implement a three-layer MLP for regression. For regression, we use linear neurons in the output layer. The neurons of the hidden layer use a nonlinear activation function. The input layer just distributes the input data into the MLP. 
We have talked about backpropagation in a separate repository. In cotnrast, we use now a matrix-form of the backpropagation and train the weights and biases of the MLP using a mini-batch of data at each step. The complete code for the MLP for regression from scratch is provided here.
36) **Variance:** The variance of a random variable measures its spread. Specifically, it is the *expected value* of the squared deviation from the *mean* of the random variable. We talked earlier about thr expected value. Here, the Python code gives examples both for discrete and continuous random variables on how to compute variance from scratch.